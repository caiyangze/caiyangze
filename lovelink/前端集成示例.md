# å‰ç«¯é›†æˆç¤ºä¾‹

## uni-appé›†æˆç¤ºä¾‹

### 1. åˆ›å»ºåŠ¨æ€APIæœåŠ¡

```javascript
// api/moment.js
import http from './http'

const momentApi = {
  /**
   * å‘å¸ƒåŠ¨æ€
   * @param {Object} data - åŠ¨æ€æ•°æ®
   * @param {Array} mediaFiles - åª’ä½“æ–‡ä»¶æ•°ç»„
   */
  createMoment(data, mediaFiles = []) {
    const formData = new FormData();
    formData.append('content', data.content);
    if (data.location) formData.append('location', data.location);
    if (data.visibility) formData.append('visibility', data.visibility);
    
    // æ·»åŠ åª’ä½“æ–‡ä»¶
    mediaFiles.forEach((file, index) => {
      formData.append('mediaFiles', file);
    });
    
    return http.request({
      url: '/api/social/moment/create',
      method: 'POST',
      data: formData,
      header: {
        'Content-Type': 'multipart/form-data'
      }
    });
  },

  /**
   * ä¸Šä¼ åŠ¨æ€å›¾ç‰‡
   * @param {String} filePath - æœ¬åœ°æ–‡ä»¶è·¯å¾„
   */
  uploadMomentImage(filePath) {
    return new Promise((resolve, reject) => {
      uni.uploadFile({
        url: http.baseUrl + '/api/social/file/upload/moment',
        filePath: filePath,
        name: 'file',
        header: {
          'token': uni.getStorageSync('token') || ''
        },
        success: (res) => {
          try {
            const data = JSON.parse(res.data);
            resolve(data);
          } catch (e) {
            reject(e);
          }
        },
        fail: (err) => {
          reject(err);
        }
      });
    });
  },

  /**
   * æŸ¥è¯¢å…¬å¼€åŠ¨æ€åˆ—è¡¨
   * @param {Number} pageNum - é¡µç 
   * @param {Number} pageSize - é¡µå¤§å°
   */
  getPublicMoments(pageNum = 1, pageSize = 10) {
    return http.request({
      url: `/api/social/moment/public?pageNum=${pageNum}&pageSize=${pageSize}`,
      method: 'GET'
    });
  },

  /**
   * æŸ¥è¯¢æˆ‘çš„åŠ¨æ€åˆ—è¡¨
   * @param {Number} pageNum - é¡µç 
   * @param {Number} pageSize - é¡µå¤§å°
   */
  getMyMoments(pageNum = 1, pageSize = 10) {
    return http.request({
      url: `/api/social/moment/mine?pageNum=${pageNum}&pageSize=${pageSize}`,
      method: 'GET'
    });
  },

  /**
   * æ›´æ–°åŠ¨æ€
   * @param {Object} data - æ›´æ–°æ•°æ®
   */
  updateMoment(data) {
    return http.request({
      url: '/api/social/moment/update',
      method: 'PUT',
      data: data
    });
  },

  /**
   * åˆ é™¤åŠ¨æ€
   * @param {Number} momentId - åŠ¨æ€ID
   */
  deleteMoment(momentId) {
    return http.request({
      url: `/api/social/moment/delete/${momentId}`,
      method: 'DELETE'
    });
  },

  /**
   * æ›´æ–°åŠ¨æ€å¯è§æ€§
   * @param {Number} momentId - åŠ¨æ€ID
   * @param {Number} visibility - å¯è§æ€§
   */
  updateMomentVisibility(momentId, visibility) {
    return http.request({
      url: `/api/social/moment/visibility/${momentId}?visibility=${visibility}`,
      method: 'PUT'
    });
  }
};

export default momentApi;
```

### 2. å‘å¸ƒåŠ¨æ€é¡µé¢

```vue
<!-- pages/moment/publish.vue -->
<template>
  <view class="publish-container">
    <view class="header">
      <button @tap="goBack" class="cancel-btn">å–æ¶ˆ</button>
      <text class="title">å‘å¸ƒåŠ¨æ€</text>
      <button @tap="publishMoment" class="publish-btn" :disabled="!canPublish">å‘å¸ƒ</button>
    </view>

    <view class="content-area">
      <textarea 
        v-model="momentData.content" 
        placeholder="åˆ†äº«ä½ çš„ç”Ÿæ´»..." 
        class="content-input"
        maxlength="1000"
        :show-count="true"
      ></textarea>
    </view>

    <view class="media-area">
      <view class="media-grid">
        <view 
          v-for="(image, index) in selectedImages" 
          :key="index" 
          class="media-item"
        >
          <image :src="image.url" class="media-image" @tap="previewImage(index)"></image>
          <view class="delete-btn" @tap="removeImage(index)">Ã—</view>
        </view>
        
        <view 
          v-if="selectedImages.length < 9" 
          class="add-media-btn" 
          @tap="chooseImage"
        >
          <text class="add-icon">+</text>
        </view>
      </view>
    </view>

    <view class="options-area">
      <view class="option-item" @tap="chooseLocation">
        <text class="option-icon">ğŸ“</text>
        <text class="option-text">{{ momentData.location || 'æ·»åŠ ä½ç½®' }}</text>
      </view>
      
      <view class="option-item" @tap="chooseVisibility">
        <text class="option-icon">ğŸ‘ï¸</text>
        <text class="option-text">{{ visibilityText }}</text>
      </view>
    </view>
  </view>
</template>

<script setup>
import { reactive, ref, computed } from 'vue';
import momentApi from '@/api/moment';

// åŠ¨æ€æ•°æ®
const momentData = reactive({
  content: '',
  location: '',
  visibility: 1 // 1-å…¬å¼€ï¼Œ2-ä»…å…³æ³¨è€…ï¼Œ3-ä»…è‡ªå·±
});

// é€‰ä¸­çš„å›¾ç‰‡
const selectedImages = ref([]);

// æ˜¯å¦å¯ä»¥å‘å¸ƒ
const canPublish = computed(() => {
  return momentData.content.trim().length > 0;
});

// å¯è§æ€§æ–‡æœ¬
const visibilityText = computed(() => {
  const texts = { 1: 'å…¬å¼€', 2: 'ä»…å…³æ³¨è€…å¯è§', 3: 'ä»…è‡ªå·±å¯è§' };
  return texts[momentData.visibility];
});

// é€‰æ‹©å›¾ç‰‡
function chooseImage() {
  const remainCount = 9 - selectedImages.value.length;
  
  uni.chooseImage({
    count: remainCount,
    sizeType: ['compressed'],
    sourceType: ['album', 'camera'],
    success: (res) => {
      res.tempFilePaths.forEach(path => {
        selectedImages.value.push({
          url: path,
          file: null // å®é™…æ–‡ä»¶å¯¹è±¡åœ¨ä¸Šä¼ æ—¶å¤„ç†
        });
      });
    }
  });
}

// ç§»é™¤å›¾ç‰‡
function removeImage(index) {
  selectedImages.value.splice(index, 1);
}

// é¢„è§ˆå›¾ç‰‡
function previewImage(index) {
  const urls = selectedImages.value.map(img => img.url);
  uni.previewImage({
    current: index,
    urls: urls
  });
}

// é€‰æ‹©ä½ç½®
function chooseLocation() {
  uni.chooseLocation({
    success: (res) => {
      momentData.location = res.name || res.address;
    }
  });
}

// é€‰æ‹©å¯è§æ€§
function chooseVisibility() {
  uni.showActionSheet({
    itemList: ['å…¬å¼€', 'ä»…å…³æ³¨è€…å¯è§', 'ä»…è‡ªå·±å¯è§'],
    success: (res) => {
      momentData.visibility = res.tapIndex + 1;
    }
  });
}

// å‘å¸ƒåŠ¨æ€
async function publishMoment() {
  if (!canPublish.value) {
    uni.showToast({
      title: 'è¯·è¾“å…¥åŠ¨æ€å†…å®¹',
      icon: 'none'
    });
    return;
  }

  uni.showLoading({
    title: 'å‘å¸ƒä¸­...'
  });

  try {
    // 1. å…ˆä¸Šä¼ å›¾ç‰‡
    const uploadPromises = selectedImages.value.map(async (image) => {
      const result = await momentApi.uploadMomentImage(image.url);
      return result.data; // è¿”å›å›¾ç‰‡URL
    });

    const imageUrls = await Promise.all(uploadPromises);

    // 2. å‘å¸ƒåŠ¨æ€
    const publishData = {
      content: momentData.content,
      location: momentData.location,
      visibility: momentData.visibility,
      imageUrls: imageUrls
    };

    await momentApi.createMoment(publishData);

    uni.hideLoading();
    uni.showToast({
      title: 'å‘å¸ƒæˆåŠŸ',
      icon: 'success'
    });

    // è¿”å›ä¸Šä¸€é¡µ
    setTimeout(() => {
      uni.navigateBack();
    }, 1500);

  } catch (error) {
    uni.hideLoading();
    console.error('å‘å¸ƒå¤±è´¥:', error);
    uni.showToast({
      title: 'å‘å¸ƒå¤±è´¥ï¼Œè¯·é‡è¯•',
      icon: 'none'
    });
  }
}

// è¿”å›
function goBack() {
  uni.navigateBack();
}
</script>

<style scoped>
.publish-container {
  min-height: 100vh;
  background-color: #f8f8f8;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20rpx 30rpx;
  background-color: #fff;
  border-bottom: 1rpx solid #eee;
}

.cancel-btn, .publish-btn {
  padding: 10rpx 20rpx;
  border: none;
  background: none;
  font-size: 32rpx;
}

.cancel-btn {
  color: #666;
}

.publish-btn {
  color: #007aff;
}

.publish-btn:disabled {
  color: #ccc;
}

.title {
  font-size: 36rpx;
  font-weight: bold;
}

.content-area {
  padding: 30rpx;
  background-color: #fff;
  margin-bottom: 20rpx;
}

.content-input {
  width: 100%;
  min-height: 200rpx;
  font-size: 32rpx;
  line-height: 1.5;
  border: none;
  outline: none;
}

.media-area {
  padding: 30rpx;
  background-color: #fff;
  margin-bottom: 20rpx;
}

.media-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 20rpx;
}

.media-item {
  position: relative;
  width: 200rpx;
  height: 200rpx;
}

.media-image {
  width: 100%;
  height: 100%;
  border-radius: 10rpx;
}

.delete-btn {
  position: absolute;
  top: -10rpx;
  right: -10rpx;
  width: 40rpx;
  height: 40rpx;
  background-color: #ff4757;
  color: #fff;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24rpx;
}

.add-media-btn {
  width: 200rpx;
  height: 200rpx;
  border: 2rpx dashed #ccc;
  border-radius: 10rpx;
  display: flex;
  align-items: center;
  justify-content: center;
}

.add-icon {
  font-size: 60rpx;
  color: #ccc;
}

.options-area {
  background-color: #fff;
}

.option-item {
  display: flex;
  align-items: center;
  padding: 30rpx;
  border-bottom: 1rpx solid #eee;
}

.option-icon {
  margin-right: 20rpx;
  font-size: 32rpx;
}

.option-text {
  font-size: 32rpx;
  color: #333;
}
</style>
```

### 3. åŠ¨æ€åˆ—è¡¨é¡µé¢

```vue
<!-- pages/moment/list.vue -->
<template>
  <view class="moment-list">
    <scroll-view 
      scroll-y 
      class="scroll-area"
      @scrolltolower="loadMore"
      refresher-enabled
      @refresherrefresh="onRefresh"
      :refresher-triggered="refreshing"
    >
      <view 
        v-for="moment in momentList" 
        :key="moment.momentId" 
        class="moment-item"
      >
        <!-- ç”¨æˆ·ä¿¡æ¯ -->
        <view class="user-info">
          <image :src="moment.avatarUrl" class="avatar"></image>
          <view class="user-details">
            <text class="nickname">{{ moment.nickname }}</text>
            <text class="time">{{ formatTime(moment.createdAt) }}</text>
          </view>
          <view v-if="moment.isMine" class="more-btn" @tap="showMoreOptions(moment)">
            <text>â‹¯</text>
          </view>
        </view>

        <!-- åŠ¨æ€å†…å®¹ -->
        <view class="content">
          <text>{{ moment.content }}</text>
        </view>

        <!-- ä½ç½®ä¿¡æ¯ -->
        <view v-if="moment.location" class="location">
          <text class="location-icon">ğŸ“</text>
          <text class="location-text">{{ moment.location }}</text>
        </view>

        <!-- åª’ä½“å†…å®¹ -->
        <view v-if="moment.mediaList && moment.mediaList.length > 0" class="media-grid">
          <image 
            v-for="(media, index) in moment.mediaList" 
            :key="media.mediaId"
            :src="media.mediaUrl" 
            class="media-image"
            @tap="previewImages(moment.mediaList, index)"
          ></image>
        </view>

        <!-- äº’åŠ¨åŒºåŸŸ -->
        <view class="actions">
          <view class="action-item" @tap="toggleLike(moment)">
            <text :class="['action-icon', moment.isLiked ? 'liked' : '']">â¤ï¸</text>
            <text class="action-text">{{ moment.likeCount || 'ç‚¹èµ' }}</text>
          </view>
          <view class="action-item" @tap="showComments(moment)">
            <text class="action-icon">ğŸ’¬</text>
            <text class="action-text">{{ moment.commentCount || 'è¯„è®º' }}</text>
          </view>
          <view class="action-item">
            <text class="action-icon">ğŸ‘ï¸</text>
            <text class="action-text">{{ moment.viewCount || 'æµè§ˆ' }}</text>
          </view>
        </view>
      </view>

      <view v-if="loading" class="loading">
        <text>åŠ è½½ä¸­...</text>
      </view>

      <view v-if="noMore" class="no-more">
        <text>æ²¡æœ‰æ›´å¤šäº†</text>
      </view>
    </scroll-view>

    <!-- å‘å¸ƒæŒ‰é’® -->
    <view class="fab" @tap="goToPublish">
      <text class="fab-icon">+</text>
    </view>
  </view>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import momentApi from '@/api/moment';

// æ•°æ®
const momentList = ref([]);
const loading = ref(false);
const refreshing = ref(false);
const noMore = ref(false);
const currentPage = ref(1);
const pageSize = 10;

// é¡µé¢åŠ è½½
onMounted(() => {
  loadMomentList();
});

// åŠ è½½åŠ¨æ€åˆ—è¡¨
async function loadMomentList(isRefresh = false) {
  if (loading.value) return;
  
  loading.value = true;
  
  try {
    const page = isRefresh ? 1 : currentPage.value;
    const result = await momentApi.getPublicMoments(page, pageSize);
    
    if (isRefresh) {
      momentList.value = result.data.records;
      currentPage.value = 1;
      noMore.value = false;
    } else {
      momentList.value.push(...result.data.records);
    }
    
    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
    if (result.data.records.length < pageSize) {
      noMore.value = true;
    } else {
      currentPage.value++;
    }
    
  } catch (error) {
    console.error('åŠ è½½åŠ¨æ€åˆ—è¡¨å¤±è´¥:', error);
    uni.showToast({
      title: 'åŠ è½½å¤±è´¥',
      icon: 'none'
    });
  } finally {
    loading.value = false;
    refreshing.value = false;
  }
}

// ä¸‹æ‹‰åˆ·æ–°
function onRefresh() {
  refreshing.value = true;
  loadMomentList(true);
}

// åŠ è½½æ›´å¤š
function loadMore() {
  if (!noMore.value) {
    loadMomentList();
  }
}

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(timeStr) {
  const time = new Date(timeStr);
  const now = new Date();
  const diff = now - time;
  
  if (diff < 60000) return 'åˆšåˆš';
  if (diff < 3600000) return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
  if (diff < 86400000) return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
  return Math.floor(diff / 86400000) + 'å¤©å‰';
}

// é¢„è§ˆå›¾ç‰‡
function previewImages(mediaList, currentIndex) {
  const urls = mediaList.map(media => media.mediaUrl);
  uni.previewImage({
    current: currentIndex,
    urls: urls
  });
}

// è·³è½¬åˆ°å‘å¸ƒé¡µé¢
function goToPublish() {
  uni.navigateTo({
    url: '/pages/moment/publish'
  });
}

// æ˜¾ç¤ºæ›´å¤šé€‰é¡¹
function showMoreOptions(moment) {
  uni.showActionSheet({
    itemList: ['ç¼–è¾‘', 'åˆ é™¤', 'è®¾ç½®å¯è§æ€§'],
    success: (res) => {
      switch (res.tapIndex) {
        case 0:
          editMoment(moment);
          break;
        case 1:
          deleteMoment(moment);
          break;
        case 2:
          changeVisibility(moment);
          break;
      }
    }
  });
}

// ç¼–è¾‘åŠ¨æ€
function editMoment(moment) {
  uni.navigateTo({
    url: `/pages/moment/edit?momentId=${moment.momentId}`
  });
}

// åˆ é™¤åŠ¨æ€
function deleteMoment(moment) {
  uni.showModal({
    title: 'ç¡®è®¤åˆ é™¤',
    content: 'ç¡®å®šè¦åˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿ',
    success: async (res) => {
      if (res.confirm) {
        try {
          await momentApi.deleteMoment(moment.momentId);
          // ä»åˆ—è¡¨ä¸­ç§»é™¤
          const index = momentList.value.findIndex(m => m.momentId === moment.momentId);
          if (index > -1) {
            momentList.value.splice(index, 1);
          }
          uni.showToast({
            title: 'åˆ é™¤æˆåŠŸ',
            icon: 'success'
          });
        } catch (error) {
          uni.showToast({
            title: 'åˆ é™¤å¤±è´¥',
            icon: 'none'
          });
        }
      }
    }
  });
}

// æ›´æ”¹å¯è§æ€§
function changeVisibility(moment) {
  uni.showActionSheet({
    itemList: ['å…¬å¼€', 'ä»…å…³æ³¨è€…å¯è§', 'ä»…è‡ªå·±å¯è§'],
    success: async (res) => {
      const visibility = res.tapIndex + 1;
      try {
        await momentApi.updateMomentVisibility(moment.momentId, visibility);
        moment.visibility = visibility;
        uni.showToast({
          title: 'è®¾ç½®æˆåŠŸ',
          icon: 'success'
        });
      } catch (error) {
        uni.showToast({
          title: 'è®¾ç½®å¤±è´¥',
          icon: 'none'
        });
      }
    }
  });
}
</script>

<style scoped>
.moment-list {
  height: 100vh;
  background-color: #f8f8f8;
}

.scroll-area {
  height: 100%;
}

.moment-item {
  background-color: #fff;
  margin-bottom: 20rpx;
  padding: 30rpx;
}

.user-info {
  display: flex;
  align-items: center;
  margin-bottom: 20rpx;
}

.avatar {
  width: 80rpx;
  height: 80rpx;
  border-radius: 50%;
  margin-right: 20rpx;
}

.user-details {
  flex: 1;
}

.nickname {
  display: block;
  font-size: 32rpx;
  font-weight: bold;
  color: #333;
}

.time {
  display: block;
  font-size: 24rpx;
  color: #999;
  margin-top: 5rpx;
}

.more-btn {
  padding: 10rpx;
  font-size: 32rpx;
  color: #999;
}

.content {
  font-size: 32rpx;
  line-height: 1.5;
  color: #333;
  margin-bottom: 20rpx;
}

.location {
  display: flex;
  align-items: center;
  margin-bottom: 20rpx;
}

.location-icon {
  margin-right: 10rpx;
  font-size: 24rpx;
}

.location-text {
  font-size: 28rpx;
  color: #666;
}

.media-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 10rpx;
  margin-bottom: 20rpx;
}

.media-image {
  width: 200rpx;
  height: 200rpx;
  border-radius: 10rpx;
}

.actions {
  display: flex;
  justify-content: space-around;
  padding-top: 20rpx;
  border-top: 1rpx solid #eee;
}

.action-item {
  display: flex;
  align-items: center;
  padding: 10rpx 20rpx;
}

.action-icon {
  margin-right: 10rpx;
  font-size: 32rpx;
}

.action-icon.liked {
  color: #ff4757;
}

.action-text {
  font-size: 28rpx;
  color: #666;
}

.fab {
  position: fixed;
  bottom: 100rpx;
  right: 50rpx;
  width: 100rpx;
  height: 100rpx;
  background-color: #007aff;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4rpx 12rpx rgba(0, 122, 255, 0.3);
}

.fab-icon {
  color: #fff;
  font-size: 48rpx;
  font-weight: bold;
}

.loading, .no-more {
  text-align: center;
  padding: 40rpx;
  color: #999;
  font-size: 28rpx;
}
</style>
```

## æ³¨æ„äº‹é¡¹

1. **Tokenç®¡ç†**: ç¡®ä¿åœ¨æ‰€æœ‰éœ€è¦è®¤è¯çš„è¯·æ±‚ä¸­æ­£ç¡®ä¼ é€’JWT token
2. **é”™è¯¯å¤„ç†**: æ·»åŠ é€‚å½“çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·æç¤º
3. **å›¾ç‰‡å‹ç¼©**: åœ¨ä¸Šä¼ å‰å¯ä»¥å¯¹å›¾ç‰‡è¿›è¡Œå‹ç¼©ä»¥æé«˜ä¸Šä¼ é€Ÿåº¦
4. **ç¼“å­˜ç­–ç•¥**: å¯ä»¥è€ƒè™‘å¯¹åŠ¨æ€åˆ—è¡¨è¿›è¡Œæœ¬åœ°ç¼“å­˜
5. **æ€§èƒ½ä¼˜åŒ–**: å¯¹äºé•¿åˆ—è¡¨ï¼Œè€ƒè™‘ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨æˆ–åˆ†é¡µåŠ è½½
