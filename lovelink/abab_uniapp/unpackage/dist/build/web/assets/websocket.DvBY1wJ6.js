import{a0 as e,a1 as t}from"./index-BpPI9udZ.js";const s=new class{constructor(){this.socket=null,this.isConnected=!1,this.reconnectTimer=null,this.heartbeatTimer=null,this.reconnectCount=0,this.maxReconnectCount=5,this.heartbeatInterval=3e4,this.reconnectInterval=5e3,this.messageHandlers=new Map,this.connectionPromise=null}connect(s){return this.isConnected||this.connectionPromise?this.connectionPromise||Promise.resolve():(this.connectionPromise=new Promise(((n,o)=>{try{const c=`${e.getWebSocketUrl()}/chat?token=${encodeURIComponent(s)}`;console.log("WebSocket连接地址:",c),this.socket=t({url:c,success:()=>{console.log("WebSocket连接请求发送成功")},fail:e=>{console.error("WebSocket连接失败:",e),this.connectionPromise=null,o(e)}}),this.socket.onOpen((()=>{console.log("WebSocket连接已建立"),this.isConnected=!0,this.reconnectCount=0,this.startHeartbeat(),this.connectionPromise=null,n()})),this.socket.onMessage((e=>{try{const t=JSON.parse(e.data);console.log("收到WebSocket消息:",t),this.handleMessage(t)}catch(t){console.error("解析WebSocket消息失败:",t)}})),this.socket.onClose((e=>{console.log("WebSocket连接已关闭:",e),this.isConnected=!1,this.stopHeartbeat(),this.connectionPromise=null,1e3!==e.code&&this.reconnectCount<this.maxReconnectCount&&this.scheduleReconnect(s)})),this.socket.onError((e=>{console.error("WebSocket连接错误:",e),this.isConnected=!1,this.connectionPromise=null,o(e)}))}catch(c){console.error("创建WebSocket连接失败:",c),this.connectionPromise=null,o(c)}})),this.connectionPromise)}disconnect(){this.socket&&this.socket.close({code:1e3,reason:"主动断开连接"}),this.isConnected=!1,this.stopHeartbeat(),this.clearReconnectTimer(),this.connectionPromise=null}send(e){if(!this.isConnected||!this.socket)return console.warn("WebSocket未连接，无法发送消息"),!1;try{const t=JSON.stringify(e);return this.socket.send({data:t,success:()=>{console.log("WebSocket消息发送成功:",e)},fail:e=>{console.error("WebSocket消息发送失败:",e)}}),!0}catch(t){return console.error("发送WebSocket消息失败:",t),!1}}sendChatMessage(e,t,s=1,n=null){const o={type:"CHAT",timestamp:Date.now(),data:{receiverId:e,messageType:s,content:t}};return n&&(o.tempId=n),console.log("发送WebSocket消息:",o),this.send(o)}sendTyping(e){return this.send({type:"TYPING",receiverId:e,timestamp:Date.now(),data:!0})}sendReadReceipt(e,t){return this.send({type:"READ",messageId:e,timestamp:Date.now(),data:t})}onMessage(e,t){this.messageHandlers.has(e)||this.messageHandlers.set(e,[]),this.messageHandlers.get(e).push(t)}offMessage(e,t){if(this.messageHandlers.has(e)){const s=this.messageHandlers.get(e),n=s.indexOf(t);n>-1&&s.splice(n,1)}}handleMessage(e){const{type:t}=e;if(this.messageHandlers.has(t)){this.messageHandlers.get(t).forEach((t=>{try{t(e)}catch(s){console.error("消息处理器执行失败:",s)}}))}}startHeartbeat(){this.stopHeartbeat(),this.heartbeatTimer=setInterval((()=>{this.send({type:"HEARTBEAT",timestamp:Date.now(),data:"ping"})}),this.heartbeatInterval)}stopHeartbeat(){this.heartbeatTimer&&(clearInterval(this.heartbeatTimer),this.heartbeatTimer=null)}scheduleReconnect(e){this.clearReconnectTimer(),this.reconnectCount++,console.log(`准备第${this.reconnectCount}次重连...`),this.reconnectTimer=setTimeout((()=>{this.connect(e).catch((e=>{console.error("重连失败:",e)}))}),this.reconnectInterval*this.reconnectCount)}clearReconnectTimer(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null)}getConnectionStatus(){return{isConnected:this.isConnected,reconnectCount:this.reconnectCount}}};export{s as w};
