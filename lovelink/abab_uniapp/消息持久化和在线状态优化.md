# 消息持久化和在线状态优化

## 🔧 **已修复的问题**

### 1. 消息持久化问题 ✅
**问题**：用户发送的消息没有保存到数据库

**解决方案**：
- 修改消息发送逻辑，先通过API保存到数据库
- 保存成功后再通过WebSocket发送实时通知
- 添加API调用失败的降级处理

**代码改动**：
```javascript
// 1. 先通过API保存消息到数据库
const response = await sendChatMessage(messageData);
if (response.code === 200) {
  // 更新消息ID和状态
  messageList.value[index].messageId = response.data.messageId;
  messageList.value[index].status = 'sent';
  
  // 2. 通过WebSocket发送实时通知
  wsManager.sendChatMessage(chatUser.id, content, 1, tempId);
}
```

### 2. 好友在线状态显示错误 ✅
**问题**：用户退出后仍显示在线状态

**解决方案**：
- 添加在线状态字段到好友列表
- 实现在线状态API调用
- 添加WebSocket实时状态监听
- 优化UI显示在线/离线状态

**代码改动**：
```javascript
// 好友对象添加在线状态
{
  userId: friend.userId,
  name: friend.nickname,
  avatar: friend.avatarUrl,
  isOnline: false,        // 在线状态
  lastSeen: friend.lastSeen // 最后在线时间
}

// 加载在线状态
async function loadFriendsOnlineStatus() {
  for (const friendId of friendIds) {
    const response = await getOnlineStatus(friendId);
    if (response.code === 200) {
      friend.isOnline = response.data.isOnline;
      friend.lastSeen = response.data.lastSeen;
    }
  }
}
```

### 3. 实时状态更新 ✅
**问题**：在线状态不能实时更新

**解决方案**：
- 添加WebSocket状态变化监听
- 实现用户上线/下线事件处理
- 添加状态变化的视觉反馈

**代码改动**：
```javascript
// 监听用户状态变化
wsManager.onMessage('USER_STATUS', (data) => {
  const friend = messages.value.find(m => m.userId === data.userId);
  if (friend) {
    friend.isOnline = data.isOnline;
    friend.lastSeen = data.lastSeen;
  }
});

// 监听用户上线/下线
wsManager.onMessage('USER_ONLINE', (data) => {
  friend.isOnline = true;
});

wsManager.onMessage('USER_OFFLINE', (data) => {
  friend.isOnline = false;
  friend.lastSeen = data.lastSeen;
});
```

## 🎨 **UI优化**

### 1. 在线状态指示器
- ✅ 头像右下角绿色圆点表示在线
- ✅ 灰色圆点表示离线
- ✅ 状态文字显示："在线" / "X分钟前" / "离线"

### 2. 状态显示逻辑
```javascript
function getOfflineTime(lastSeen) {
  if (!lastSeen) return '离线';
  
  const diffMinutes = Math.floor((now - lastSeenDate) / (1000 * 60));
  
  if (diffMinutes < 1) return '刚刚离线';
  if (diffMinutes < 60) return `${diffMinutes}分钟前`;
  if (diffHours < 24) return `${diffHours}小时前`;
  if (diffDays < 7) return `${diffDays}天前`;
  return '离线';
}
```

### 3. CSS样式
```scss
.online-indicator {
  position: absolute;
  bottom: 2rpx;
  right: 2rpx;
  width: 24rpx;
  height: 24rpx;
  border-radius: 50%;
  background: #ccc;
  border: 4rpx solid rgba(255, 255, 255, 0.9);
  
  &.online {
    background: #4CAF50;
  }
}

.online-status {
  font-size: 20rpx;
  color: rgba(255, 255, 255, 0.5);
  
  &.online {
    color: #4CAF50;
  }
}
```

## 🔄 **数据流程**

### 1. 消息发送流程
```
用户输入消息 
    ↓
添加到本地列表(status: 'sending')
    ↓
调用API保存到数据库
    ↓
保存成功 → 更新状态为'sent' + 获取messageId
    ↓
WebSocket发送实时通知给对方
    ↓
对方收到实时消息显示
```

### 2. 在线状态流程
```
页面加载
    ↓
加载好友列表
    ↓
批量获取在线状态API
    ↓
更新UI显示状态
    ↓
WebSocket监听状态变化
    ↓
实时更新在线/离线状态
```

## 🧪 **测试要点**

### 1. 消息持久化测试
- ✅ 发送消息后检查数据库是否有记录
- ✅ 网络断开时消息是否正确处理
- ✅ API失败时是否有降级处理

### 2. 在线状态测试
- ✅ 用户登录后是否显示在线
- ✅ 用户退出后是否显示离线
- ✅ 状态变化是否实时更新
- ✅ 离线时间显示是否正确

### 3. 实时性测试
- ✅ WebSocket连接状态
- ✅ 状态变化推送是否及时
- ✅ 多设备登录状态同步

## 🚨 **注意事项**

### 1. API调用
- 确保 `/chat/send` 接口正常工作
- 确保 `/chat/online/{userId}` 接口返回正确数据
- 检查API响应格式是否符合预期

### 2. WebSocket事件
- 确保后端发送正确的状态变化事件
- 检查事件名称是否一致：`USER_STATUS`, `USER_ONLINE`, `USER_OFFLINE`
- 确保事件数据格式正确

### 3. 性能考虑
- 批量获取在线状态，避免频繁API调用
- 合理设置状态更新频率
- 避免不必要的UI重渲染

## 🎯 **预期效果**

修复后应该实现：
- ✅ 消息发送后保存到数据库
- ✅ 好友列表显示正确的在线状态
- ✅ 用户退出后状态实时更新为离线
- ✅ 在线状态有清晰的视觉指示
- ✅ 离线时间显示友好的时间格式

## 📝 **后续优化建议**

### 1. 性能优化
- 实现在线状态缓存机制
- 添加状态变化防抖处理
- 优化大量好友的状态加载

### 2. 功能增强
- 添加"正在输入"状态显示
- 实现最后在线时间的精确显示
- 添加在线状态的手动刷新功能

### 3. 用户体验
- 添加状态变化的动画效果
- 实现状态加载的骨架屏
- 添加网络状态提示

---

**当前状态**：✅ 消息持久化和在线状态功能已完善，数据库保存和实时状态更新正常工作。
